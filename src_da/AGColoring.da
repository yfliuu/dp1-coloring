import networkx as nx
import lib
import vis
import math


class P(process):
    def setup(neighbors:list, idmapping:list, n:int, nid:int, delta:int, q:int, color:int):
        # ------ROM------
        self.delta = delta
        self.q = q
        self.counter = 0
        self.nid = nid # Integer id
        self.idmapping = idmapping

        # ------RAM------
        self.color = (math.floor(color / self.q), color % self.q)
        self.responded = []
        self.term_response = set()

    def run():
        send(('Color', self.color), to=neighbors)
        while True:
            await(len(self.responded) == len(self.neighbors))
            # print('d{} += {}'.format(self.nid, [self.idmapping[x] for x in self.neighbors]))

            if any(map(lambda x: x[1] == self.color[1], self.responded)):
                # Conflict
                self.color = (self.color[0], (self.color[0] + self.color[1]) % self.q)
                # self.responded.clear()
            else:
                # Finalize
                self.color = (0, self.color[1])
                output('My color: ' + str(self.color))

                # break
            self.responded.clear()
            send(('Color', self.color), to=neighbors)

        output('exit')

    def receive(msg=('Color', color), from_=src):
        # print('d{}.remove({})'.format(self.nid, self.idmapping[src]))
        self.responded.append(color)

def main():
    config(channel="reliable")
    n = 5
    ps = new(P, num=n)

    id_mapping = {p: id for id, p in enumerate(ps)}
    rev_mapping = {id: p for id, p in enumerate(ps)}

    G = lib.gen_random_graph(n, 10)
    vis.plot(G, node_text=rev_mapping)
    # coloring = lib.trivial_coloring(G)
    delta = lib.calc_delta(G)
    print('Maximum degree: ' + str(delta))

    for id, adj in G.adjacency():
        nbs_id = list(adj.keys())
        nbs_rev = [rev_mapping[i] for i in nbs_id]
        setup({rev_mapping[id]}, (nbs_rev, id_mapping, n, id, delta, lib.choose_prime(delta), id))
    start(ps)
