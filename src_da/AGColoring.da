import networkx as nx
import lib
import vis


class P(process):
    def setup(neighbors:list, delta:int, q:int, color_a:int, color_b:int):
        # ------ROM------
        self.delta = delta
        self.q = q

        # ------RAM------
        self.color = (color_a, color_b)
        self.responded = set()

    def run():
        while True:
            send(('Color', self, self.color), to=neighbors)
            await(len(self.responded) == len(self.neighbors))
            if any(map(lambda x: x[1] == self.color[1], self.responded)):
                # Conflict
                self.color = (self.color[0], (self.color[0] + self.color[1]) % self.q)
            else:
                # Finalize
                output('My color: ' + str(self.color))
                break

    def receive(msg=('Color', id, color), from_=src):
        self.responded.add(color)


def main():
    config(channel="fifo")
    n = 10
    ps = new(P, num=n)

    # id_mapping = {p: id for id, p in enumerate(ps)}
    rev_mapping = {id: p for id, p in enumerate(ps)}


    G = nx.random_geometric_graph(n, 0.125)
    # coloring = lib.trivial_coloring(G)
    delta = max([d for _, d in G.degree])
    print('Maximum degree: ' + str(delta))

    for id, adj in G.adjacency():
        nbs_id = list(adj.keys())
        nbs_rev = [rev_mapping[i] for i in nbs_id]
        setup({rev_mapping[id]}, (nbs_rev, delta, lib.choose_prime(delta), 0, id))
    start(ps)
